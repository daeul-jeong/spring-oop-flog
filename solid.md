객제지향 설계 5원칙 - SOLID

SRP single responsibility principle 
단일 책임 원칙
> 어떤 클래스를 변경해야하는 이유는 오직 하나 뿐이어야 한다

OCP open closed principle
개방 폐쇄 원칙
> 자신의 확장에는 열려 있고 주변의 변화에 대해서는 닫혀 있어야 한다

LSP liskov substitution principle 
리스코프 치환 원칙
> 서브 타입은 언제나 자신의 기반 타입으로 교체 할 수 있어야 한다

ISP interface segregation principle 
인터페이스 분리 원칙
> 그는 자신을 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다

DIP dependency inversion principle
의존 역전 원칙
> 자신보다 변하기 쉬운것에 의존하지 마라

>> 응집도는 높이고 결합도는 낮춘다



---------
SRP single responsibility principle 
단일 책임 원칙

ex) 남자 클래스
남자친구, 아들, 소대장 역할... > 냄새나는 코드
남자친구 클래스
아늘 클래스  
소대장 클래스

역할을 나눈다 

ex) 하나의 필드 값이 토지인 경우, 면적으로 사용
건물인 경우, 층수 > 단일 책임 원칙 위배

ex) 강아지 클래스
소변보다() 메서드 > 여자면 앉아서 남자면 다리 들고
>>> 단일 책임 원칙 위배, if가 있는 경우.. 위배 가능성 큼

강아지 클래스를 만들고
상속하여 숫컷 강아지, 암컷 강아지를 만들고
각각 클래스에 소변보다()를 구현할 것



﻿OCP open closed principle
개방 폐쇄 원칙
>> 자신의 확장에는 열려있고 주변의 변화에 대해서는 닫혀 있어야 한다

﻿ex) 
자동차 클래스 ( 또는 인터페이스 ) 를 두고
하위 클래스로 마티즈, 쏘나타를 만들어서
각각의 창문개방, 기어조작 방법을 구현한다

ex) jdbc
설정 파일을 따로 두어서
오라클이든 mysql이든 설정 값만 바꾸고
소스코드눈 변경 없는 것
> 데이터 베이스 교체 = 자신의 확장에 열려있음
> 변경으로 인해 코드 수정 없는 것 = 주변의 변화에 닫혀있음

ex) 자바
> 자바 코드는 운영체제 변화에 닫혀있고
> 운영체제 별 jvm은 확장에 열려있음 
( 소스코드, 운영체제별 jvm 사리이는 목적 파일이라고 하는 완충 장치가 있음)

ex) 편의점
교대 근무를 하더라도 판매 인터페이스에는 변함이 없음
> 직원 교대라고 하는 주변의 변화에 손님의 구매행위는 영향을 받지 않은다
>직원은 교대라는 확장 행위에 열려있다
> 담당자를 추가하는 항위에도 직원은 열려있음

LSP liskov substitution principle 
리스코프 치환 원칙

﻿하위 클래스 is a kind of 상위 클래스 = 하위 분류는상위 분류의 한 종류다
﻿구현 클래스 is able to 인터페이스 = 구현 분류는 인터페이스할 수 있어야한다

- 상속을 계층 구조로 사용하면 안된다
- 분류가 되어야한다. 



ISP interface segregation principle 
인터페이스 분리 원칙

﻿클래스를 분리하지 않고 
인터페이스를 두어서 각 역할을 나눈다
- 단일 책임 원칙과 인터페이스 분할 원칙은 같은 문제에 대한 다른 해결책임
- 특별한 경우가 아니라면 단일 책임 원칙이 더 낫다

- 상위 클래스는 풍성할수록 좋고 인터페이스는 작을수록 좋다



﻿DIP dependency inversion principle
의존 역전 원칙
자신보다 변하기 쉬운 것에 의존하지 마라
ex ) 자동차가 스노우 타이어에 종속적인 경우> 계절마다 바뀌어야한다
> 자동차가 타이어 인터페이스를 의존하게 만들고 
스노우 타이어, 일반 타이어를 구현한다


정리
﻿
﻿ 관심사의 분리 separation of concerns
속성, 메서드, 클래스, 모듈, 패키지 각각에는 하나의 관심사만 있어야한다

﻿ 

